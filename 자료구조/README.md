# 자료구조

## 링크드 리스트
배열과의 비교가 중요
1. 배열은 연속적인 메모리 공간이므로 검색시 빠르다.
2. 배열은 크기가 정적이다 링크드 리스트는 크기가 동적
## 스택
* LIFO(Last in first out) 마지막에 삽입된 원소가 먼저 삭제됨  
* push 
* pop
## 큐
* FIFO(First in first out) 먼저 삽입된 원소가 먼저 삭제됨
* front에서 삽입 rear에서 삭제
* add
* delete
* ArrayQueue의 문제점 - 삽입시 rear증가 삭제시 front 증가 -> queue가 full이 될 경우 전체를 이동하여 front/rear를 조정해야 함 -> 원형큐사용
### 원형큐
* front가 맨앞 rear가 맨 뒤
* % (Modular)연산을 이용   
rear=(rear+1)% Max_size  
front=(front+1)% Max_size
* front가 있는자리는 비워둔다. 
front=rear라면 empty   
rear+1=front라면 full  
## 트리

### 이진탐색트리(Binary Search Tree)

### 레드블랙트리
## 그래프
## 해시테이블  
해시 값에 따라 리스트에 저장하는 방법  
해시 값이 같은 경우 충돌이 발생한다.
### 충돌해결방법
* 선형조사 - 충돌이 발생하면 다음 빈공간을 찾는다. -> 군집화문제가 발생한다  탐색,삽입,삭제시 해시 값의 자리를 찾은 뒤 밀려난 만큼 군집된 키들을 순차적으로 방문해야하므로 성능이 떨어진다.

* 이차조사 - 충돌이 발생하면 n^2 만큼 건너뛰어 빈공간을 찾는다. -> 앞서 군집화문제는 해결하지만 또다시 2차 군집화가 생긴다. 또한 바로 옆에 빈공간이 있는데도 건너뛰어 저장실패가 일어날 수 도 있다.

* 랜덤조사 - 충돌이 발생하면 랜덤한 위치로 이동해서 빈공간을 찾는다.

* 이중해싱 - 해싱이후 충돌이 발생하면 한번더 해싱해서 저장한다. -> 군집화가 해결된다! 

* 체이닝 - 충돌이 발생하면 링크드리스트를 이용해서 뒤에 계속 이어준다. -> 어느 해시값에 값이 모여있으면 성능이 떨어진다.

* 재해싱 - 테이블을 늘리고 새로운 해시테이블에 맞게 다시 해싱한다. 
